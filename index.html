<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>index - zPurse Protocol v0</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/pagetoc.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html" class="active"><strong aria-hidden="true">1.</strong> index</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">zPurse Protocol v0</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <div class="content-wrap">
                            <h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>At a high level, the zPurse protocol enables an account based system to convert assets into a UTXO based accounting system in a smart contract using notes with cloaked owners and amounts, while using zk proofs to verify UTXO transitions.</p>
<p>What this looks like is a smart contract on Ethereum with a mapping from note ID to a hash of note metadata. The metadata for a note simply contains the balance of the note, and the address of who can spend it. The contract then has one public function called updateNotes that takes in a list of old notes, a list of new notes, and a proof that the transition is valid.</p>
<h2 id="motivations"><a class="header" href="#motivations">Motivations</a></h2>
<p>The initial motivation for this work came from the realization that messaging protocols have matured to the point where payment signaling can be delegated to out of band transport layers.</p>
<p>By decoupling this requirement, you suddenly can gain all sorts of interesting privacy properties, as well as properties that enable things like offline transactions and physical payment tokens, with assets sitting on any number of networks, that can all be trivially abstracted away from the UX of less technical users. This document hopes to describe a simplified early version of what might be accomplished in the future.</p>
<p>There exists a dilemma where secure payments require strong identity bindings to the reciever of any funds being sent, but payments are rarely intended to be visible to the general public. How do we allow users to have some sense of personal privacy while also ensuring that recipients aren't impersonators, or other types of scammers?</p>
<h2 id="goals"><a class="header" href="#goals">Goals</a></h2>
<p>I want to outline a very simple protocol where anyone with an armchair cryptographer level of understanding can fully conceptualize the security properties of the system.</p>
<p>Users with funds in the system should be able to easily transfer funds to anyone with an Ethereum address. For simplicity of the initial design, only EOAs are considered, though smart contracts could probably be enabled easily enough.</p>
<h2 id="anti-goals"><a class="header" href="#anti-goals">Anti-Goals</a></h2>
<p>This spec is fully non opinionated about the zk proving system in use. For the sake of simplicity, a system like RiscZero that can do verifiable computation on arbitrary rust code might be the easiest to conceptualize.</p>
<p>I don't really care about performance. It would be nice if users could prove note updates on their phones in under a minute or so, but proving costs nor contract gas costs are considered here.</p>
<p>In general, there is no on-chain way for a user to detect when they have received a note. This is a feature.</p>
<h2 id="deposits-and-withdrawals"><a class="header" href="#deposits-and-withdrawals">Deposits and Withdrawals</a></h2>
<p>The updateNotes function has an optional field for regular ERC-20 inputs or outputs. The user would construct an updateNote transaction indicating the number of assets, lets say DAI, that they want to move into the Purse. They would then also submit an empty list of input notes and a short list of output notes, with themselves as the spender on those notes. There are also situations where someone might want to deposit directly to another spender. Of course ERC-20 funds could be withdrawn at any time as well.</p>
<h2 id="sending-and-receiving-funds"><a class="header" href="#sending-and-receiving-funds">Sending and Receiving Funds</a></h2>
<p>When a user wants to send funds, first they find a set of input notes with the required amount of funding. They must control the EOA private key for the spender of any notes that are used. They then construct a set of output notes setting the proper spenders and amounts accordingly. One of the notes might be the destination for the funds, and another might be a change address to deposit any leftover funds. Another might be a tip for an external party to commit the update to the chain. Notice this is very similar to how Bitcoin constructs transactions in the UTXO model, where the output notes are the unspent transaction outputs.</p>
<p>Once the input and output notes are decided, the user then creates a zero knowledge proof (described in the next section) that the inputs and outputs represent a legitimate note transition. That set of inputs, outputs, and the proof is known as the NoteUpdate.</p>
<p>At this point, the NoteUpdate can be committed directly to the Purse by the user, send to a NoteUpdate Aggregator, or sent directly to the intended recipient of the funds. Either way, the recipient must also then be informed that they have received funds. How this is communicated is out of scope for this spec, but for the purposes of this example you can imagine a message being sent over the XMTP network saying "you have a new note", and including the note id, the spender address, the balance of the note, and the nonce.</p>
<p>The recipient will then be able to hash the metadata together, and query the state of the contract directly to confirmed that they do, in fact, own that new note. If the user has received an Uncommitted Note, they can verify the proof and that one of the output notes contains the intended funds. They would then have the option to commit the NoteUpdate themselves.</p>
<p>Of course this entire process would be hidden by a simple UX where a user simply sends a transaction just like they would in any other payment app.</p>
<h2 id="proving"><a class="header" href="#proving">Proving</a></h2>
<p>The exact details of the proving zero knowledge proving scheme are out of scope for this document, but the conceptual black box is a prover with a set of inputs, a set of outputs, a program to run on the inputs, and a receipt that proves execution was done correctly.</p>
<p>In this case, the inputs include the input and output notes, including all of the note metadata (spender, balance, nonce), as well as a signature from the spender proving that they hold the spending key.</p>
<h3 id="prove-the-spender"><a class="header" href="#prove-the-spender">Prove the Spender</a></h3>
<p>First, we need to prove that the designated spender is the one generating the proof. We want to make sure that any zPurse client doesn't actually need the private key, so the signature should come from any normal Web3 wallet, such as Metamask. The data being signed should be a hash of all relevant input and output notes, not including the spender.</p>
<p>Inside the prover, all we're doing is a normal ERC???? signature check, but we also need to make sure that we hash the notes as well to confirm that the signature is commiting to the right set of notes.</p>
<h3 id="prove-the-meta-hashes"><a class="header" href="#prove-the-meta-hashes">Prove the Meta Hashes</a></h3>
<p>It is important to confirm that all of the metadata sent in actually Hashes to the MetaHash field on the input and output notes themselves.</p>
<h3 id="prove-the-notes-are-balanced"><a class="header" href="#prove-the-notes-are-balanced">Prove the Notes are Balanced</a></h3>
<p>It is important to confirm that the sum of the balances of the input notes exactly equal the sum of the balances of the output notes.</p>
<h3 id="return-the-results"><a class="header" href="#return-the-results">Return the Results</a></h3>
<p>Now we can return all of the notes, without the metadata attached, and the execution receipt that proves all the checks were performed correctly. Notice that there is no information about the spender in the final NoteUpdate.</p>
<h3 id="potential-for-recursion"><a class="header" href="#potential-for-recursion">Potential for Recursion</a></h3>
<p>This proving scheme could also add the option of including any number of previously proven NoteUpdates by calling the verifier from inside the prover. This means that thousands of  input and output notes with any number of spenders could be aggregated into a single NoteUptate. It is important to keep in mind, however, that every input note in the NoteUpdate must match the meta hash value in the registry, or the entire NoteUpdate will be invalid and will not be able to be committed.</p>
<h2 id="tipping-conventions"><a class="header" href="#tipping-conventions">Tipping Conventions</a></h2>
<p>For the sake of operational security, users should generally refrain from committing their own note updates. Instead they can designate one of their OutputNotes as TipNote to a specific "Note Aggregator", who would be the one actually responsible for committing the note to the chain.</p>
<p>If a user isn't confident that the Aggregator will submit their NoteUpdate in a timely manner, they might generate multiple NoteUpdates with tips to different aggregators which would only be valid for the first aggregator that submits it.</p>
<h2 id="offline-note-transfers"><a class="header" href="#offline-note-transfers">Offline Note Transfers</a></h2>
<p>Notice that nothing in this system requires the sender or receiver of funds to be online. In a scenario where there is some social trust, as is common with in-person interactions, the sender could send a NoteUpdate and the Note Metadata to the recipient via QR code, or bluetooth, or whatever other message sending is available. The recipient's wallet could then verify the proof, and verify the input notes against the last known state of the Purse contract. These funds could be double-spent until the NoteUpdate is able to be broadcast and committed, so it should not be used in low-trust situations.</p>
<p>This same mechanism could enable the use of NFC based physical coins. A note would be created where the spender key is in the NFC chip itself. A phone with the recent state of the NoteRegistry could use the NFC reader to confirm the legitimacy of the coin. If the coin is illegitimately duplicated it would be immediately apparent once the Note is spent. Coins would be passed around mostly in scenarios where some social trust is involved, and would likely be spent immediately when used in a low-trust environment, such as when spent at a retail establishment. The coins could then be regularly reloaded and reused.</p>
<h2 id="social-backup"><a class="header" href="#social-backup">Social Backup</a></h2>
<p>Someone who loses access to their list of notes would no longer be able to spend them. Since zPurse payment identities are just web3 identities, the web3 social graph (Farcaster, Lens, etc) of any user can be leveraged to back up notes. The stack of notes should be encrypted, and sufficiently padded so that the number of notes is difficult to ascertain, but it is also interesting that even if that user manages to decrypt the bundle, they would still not be able to spend any of the notes without the spending key.</p>
<h2 id="privacy-properties"><a class="header" href="#privacy-properties">Privacy Properties</a></h2>
<p>Unlike many other payment systems, the receiver of funds is generally unaware of who sent them. A wallet would likely mark the sender as whatever entity made them aware of the note, which may or may not be the one who actually sent the funds. Interestingly, this also means that a potential recipient can make a payment request, asking anyone to create a new note with a given sender, balance, and nonce. That way, the sender does not need to figure out how to inform the recipient of the transfer. The recipient will just be made aware of the successful transfer once the note shows up in the registry. Since the registry can be accessed by smart contracts on the same blockchain network, this could potentially be used for various automation use cases.</p>
<h2 id="note-states"><a class="header" href="#note-states">Note States</a></h2>
<ul>
<li>Illegitimate: Even with a NoteUpdate, the Note Meta does not map to a legitimate Note</li>
<li>Unconfirmed: A bundled NoteUpdate has a verified proof, and matching OutputNote, but the NoteID is not in the registry yet</li>
<li>Confirmed: The NoteID exists in the registry, and the hash of the metadata matches the public MetaHash.</li>
<li>Spent: The Note was valid, but has been spent.</li>
</ul>
<h2 id="mobile-app-considerations"><a class="header" href="#mobile-app-considerations">Mobile App Considerations</a></h2>
<ul>
<li>No need for private key! Just set spender.</li>
<li>Point to any number of purses on any number of chains and abstract transactions away.</li>
<li>Should also be an XMTP client.</li>
</ul>
<h2 id="limitations"><a class="header" href="#limitations">Limitations</a></h2>
<ul>
<li>Two unconfirmed transactions can't be aggregated in the same batch.</li>
<li>UTXO Forensics is a thing.</li>
<li>No fancy smart contracts.</li>
</ul>
<h2 id="concerns"><a class="header" href="#concerns">Concerns</a></h2>
<p>Each purse instance holds all the underlying assets for all users, and if the Verifier can be tricked into verifying a forged transaction, an attacker can take all the money out. It's basically a giant money pinata.</p>
<h2 id="emergency-exits"><a class="header" href="#emergency-exits">Emergency Exits</a></h2>
<p>In the event of a critical soundness bug in the verifier, a Whitehat could craft a transaction that would remove more funds than actually exist in the contract. In that case, the Purse would go into emergency mode. No more deposits or note updates would be allowed, and people would be able to safely withdraw their funds.</p>
<h2 id="future"><a class="header" href="#future">Future</a></h2>
<p>It would be simple to add a token id so any given purse could also hold arbitrary ERC20 tokens.</p>
<p>Note updates could be proven recursively, effectively aggregating any number of note transitions into a single update. An Update Aggregator would prove their own input and output notes, and then as part of their proof, verify any number of other noteTxProofs.</p>
<p>Purses with different verifiers could be set up to perform transfers between each other, perhaps even cross chain using LayerZero or any other system that supports cross chain message passing.</p>
<p>It would be nice to enable contracts to be note owners, for purposes of account abstraction as well as potentially enabling certain DeFi use cases.</p>
<p>I have been told that Fully Homomorphic Encryption might allow for the entire note registry to be hidden, so an outside observer would not be able to see what notes are being operated on. It's unclear to me if this would make note observability overly complicated for receivers of notes.</p>
<p>Should this be an ERC?</p>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<ul>
<li>Purse: This is the smart contract. It holds all the assets for all the users. Is has a NoteRegistry, a function to update the notes, and a zk verifier to verify note transitions.</li>
<li>Note: This is the standard unit of value in the zPurse system.</li>
<li>NoteRegistry: This is public mapping on the contract from NoteID to NoteMetaHash. No other details about the notes can be seen publicly.</li>
<li>NoteID: This is an integer value representing a note. It is public, and ideally random so users don't accidentally create conflicting output notes.</li>
<li>NoteMetaHash: Publicly visible hash of the spender, balance, and nonce.</li>
<li>Spender : This is a web3 EOA who has permission to spend a note.</li>
<li>Balance : How much of an asset is sitting in a note.</li>
<li>Nonce : Random number to prevent the brute forcing of NoteMetaHash's, since the other two fields can be relatively low entropy.</li>
</ul>
<h2 id="call-for-participation"><a class="header" href="#call-for-participation">Call for Participation</a></h2>
<p>This is a very early draft. Most of which was typed out on a phone while on an airplane. There are likely several typos and inconsistencies. Any protips on how to make mdbook sites look pretty would be awesome.</p>
<p>Leave issues on GitHub, and send pull requests. Any feedback is greatly appreciated.</p>
<p>https://github.com/pierce403/zPurse</p>
<h2 id="inspiration"><a class="header" href="#inspiration">Inspiration</a></h2>
<p>Bitcoin, Zero Cash, Tornado Cash, and especially Aztec's join-split note mechanism. Of course none of this would be practical today without the fine work happening on Ethereum, XMTP, Farcaster, and RiscZero as well.</p>

                        </div>
                        <div class="sidetoc">
                            <nav class="pagetoc"></nav>
                        </div>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="theme/pagetoc.js"></script>


    </div>
    </body>
</html>